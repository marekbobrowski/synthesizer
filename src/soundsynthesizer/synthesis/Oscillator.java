package soundsynthesizer.synthesis;

import soundsynthesizer.delegates.IntGetter;

/**
 * This class is responsible for generating sound waves according to the specified parameters.
 *
 * @author Marek Bobrowski
 */
public class Oscillator {
    /**
     * An integer getter delegate for getting the wave type number.
     */
    private final IntGetter waveTypeGetter;

    /**
     * The phase of this oscillator.
     */
    private double phase;

    /**
     * Oscillator constructor.
     * @param waveTypeGetter An integer getter delegate for getting the wave type number.
     */
    public Oscillator(IntGetter waveTypeGetter) {
        this.waveTypeGetter = waveTypeGetter;
        this.phase = 0;
    }

    /**
     * Gathers a sound buffer according to the passed method arguments and this oscillator's class fields.
     * @param frequency The frequency of the wave to be generated.
     * @param bufferSize The number of frames of the buffer.
     * @return The buffer generated by this oscillator.
     */
    public double[][] gatherBuffer(double frequency, int bufferSize) {
        int waveTypeNumber = waveTypeGetter.get();
        return switch (waveTypeNumber) {
            case 1 -> bufferWithTriangle(frequency, bufferSize);
            case 2 -> bufferWithSawtooth(frequency, bufferSize);
            case 3 -> bufferWithPulse(frequency, bufferSize);
            /* 0 (default) - sine wave */
            default -> bufferWithSine(frequency, bufferSize);
        };
    }

    /**
     * Creates a buffer of a sine wave.
     * @param frequency The frequency of the sine wave.
     * @param bufferSize The number of frames of the sound buffer.
     * @return The generated sine wave buffer.
     */
    private double[][] bufferWithSine(double frequency, int bufferSize) {
        double[][] buffer = new double[2][bufferSize];
        for (int i = 0; i < bufferSize; i++) {
            buffer[0][i] = Math.sin(this.phase);
            buffer[1][i] = buffer[0][i];
            this.phase += ((2 * Math.PI * frequency) / Converter.SAMPLE_RATE);
            if (this.phase > 2 * Math.PI) {
                this.phase = this.phase - (2 * Math.PI);
            }
        }
        return buffer;
    }

    /**
     * Creates a buffer of a triangle wave.
     * @param frequency The frequency of the triangle wave.
     * @param bufferSize The number of frames of the sound buffer.
     * @return The generated triangle wave buffer.
     */
    private double[][] bufferWithTriangle(double frequency, int bufferSize) {
        double[][] buffer = new double[2][bufferSize];
        for (int i = 0; i < bufferSize; i++) {
            if (this.phase < Math.PI) {
                buffer[0][i] = -1 + (2/Math.PI)*this.phase;
            } else {
                buffer[0][i] = 3 - (2/Math.PI)*this.phase;
            }
            buffer[1][i] = buffer[0][i];

            this.phase += ((2 * Math.PI*frequency)/Converter.SAMPLE_RATE);

            if (this.phase > 2 * Math.PI) {
                this.phase = this.phase - (2 * Math.PI);
            }
        }
        return buffer;
    }

    /**
     * Creates a buffer of a sawtooth wave.
     * @param frequency The frequency of the sawtooth wave.
     * @param bufferSize The number of frames of the sound buffer.
     * @return The generated sawtooth wave buffer.
     */
    private double[][] bufferWithSawtooth(double frequency, int bufferSize) {
        double[][] buffer = new double[2][bufferSize];
        for (int i = 0; i < bufferSize; i++) {
            buffer[0][i] = 1 - (1 / Math.PI * this.phase);
            buffer[1][i] = buffer[0][i];
            this.phase += ((2 * Math.PI * frequency) / Converter.SAMPLE_RATE);
            if (this.phase > 2 * Math.PI) {
                this.phase = this.phase - (2 * Math.PI);
            }
        }
        return buffer;
    }

    /**
     * Creates a buffer of a pulse wave.
     * @param frequency The frequency of the pulse wave.
     * @param bufferSize The number of frames of the sound buffer.
     * @return The generated pulse wave buffer.
     */
    private double[][] bufferWithPulse(double frequency, int bufferSize) {
        double[][] buffer = new double[2][bufferSize];
        for (int i = 0; i < bufferSize; i++) {
            if (this.phase < Math.PI) {
                buffer[0][i] = 1;
            } else {
                buffer[0][i] = -1;
            }
            buffer[1][i] = buffer[0][i];
            this.phase += ((2 * Math.PI * frequency) / Converter.SAMPLE_RATE);
            if (this.phase > 2 * Math.PI) {
                this.phase = this.phase - (2 * Math.PI);
            }
        }
        return buffer;
    }
}

