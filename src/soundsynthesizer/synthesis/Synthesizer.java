package soundsynthesizer.synthesis;

import java.util.concurrent.CopyOnWriteArrayList;

/**
 * This class is responsible for running and managing the whole process of synthesis:
 * creating voices, mixing them, applying effects and sending to output.
 *
 * @author Marek Bobrowski
 */
public class Synthesizer implements Runnable {
    /**
     * A list of voices that are currently being generated.
     */
    private final CopyOnWriteArrayList <Voice> voices = new CopyOnWriteArrayList<>();

    /**
     * A list of voices that are going to be removed after the current buffer.
     */
    private final CopyOnWriteArrayList <Voice> voicesToBeRemoved = new CopyOnWriteArrayList<>();

    /**
     * A list of voices that are going to be generated within the next buffer.
     */
    private final CopyOnWriteArrayList <Voice> voicesToBeAdded = new CopyOnWriteArrayList<>();

    /**
     * The delay effect used to process the sound of this synthesizer.
     */
    private final Delay delay = new Delay();

    /**
     * The reverberation effect used to process the sound of this synthesizer.
     */
    private final Reverb reverb = new Reverb();

    /**
     * The converter that is going to stream the signal from this synthesizer to a sound card.
     */
    private final Converter converter = new Converter();

    /**
     * The envelope settings of the voices generated by this synthesizer.
     */
    private final EnvelopeSettings envelopeSettings = new EnvelopeSettings();

    /**
     * The settings of the oscillators that generate sound for this synthesizer.
     */
    private final OscillatorSettings oscillatorSettings = new OscillatorSettings();

    /**
     * The output loudness of this synthesizer.
     */
    private final Volume volume = new Volume();

    /**
     * Tells if this synthesizer should keep buffering new sound.
     */
    private boolean keepBuffering = false;

    /**
     * Empty constructor.
     */
    public Synthesizer() {
    }

    /**
     * Add the voice to the "waiting room" - 'voicesToBeAdded' list.
     * @param newVoice The voice to be added.
     */
    public void addNewVoice(Voice newVoice) {
        voicesToBeAdded.add(newVoice);
    }

    /**
     * Add the voice to the 'voicesToBeRemoved' list.
     * @param voice The voice to be finished.
     */
    public void finishVoice(Voice voice) {
        voicesToBeRemoved.add(voice);
    }

    /**
     * Remove the 'voicesToBeRemoved' list from the 'voices' list.
     */
    private void removeFinishedVoices() {
        for(Voice n: voicesToBeRemoved) {
            voices.remove(n);
        }
        voicesToBeRemoved.clear();
    }

    /**
     * Add all voices from the 'voicesToBeAdded' list to the 'voices' list.
     */
    private void acceptNewVoices() {
        voices.addAll(voicesToBeAdded);
        voicesToBeAdded.clear();
    }

    /**
     * Gathers buffers from all the voices.
     * @param bufferSize The number of frames of a sound buffer.
     * @return The array of sound buffers created by all the voices.
     */
    private double[][][] gatherAllVoices(int bufferSize) {
        double[][][] allVoiceBuffers = new double[voices.size()][2][bufferSize];
        int index = 0;
        for(Voice n : voices) {
            if (index >= allVoiceBuffers.length) {
                break;
            }
            allVoiceBuffers[index] = n.prepareBuffer(bufferSize);
            index++;
        }
        return allVoiceBuffers;
    }

    /**
     * Returns mixed and processed sound of all buffers.
     * @param buffer The buffer to be processed.
     */
    private double[][] createPostProcessedBuffer(double[][] buffer) {
        delay.processBuffer(buffer);
        buffer = reverb.createProcessedBuffer(buffer);
        volume.processBuffer(buffer);
        return buffer;
    }

    /**
     * Mixes the passed buffers. First index stands for the buffer number,
     * second index stands for the channel number, third index stands for the frame number.
     * @param buffers Array of buffers (made in the format specified in the method description).
     * @param bufferSize The number of frames of a sound buffer.
     * @return The buffer with the mixed signal.
     */
    private static double[][] mixBuffers(double[][][] buffers, int bufferSize) {
        double[][] mixedBuffers = new double[2][bufferSize];
        for (int i = 0; i < bufferSize; i++) {
            for (int j = 0; j < buffers.length; j++) {
                if(i < buffers[j][0].length) {
                    mixedBuffers[0][i] += buffers[j][0][i]/16;
                    mixedBuffers[1][i] += buffers[j][1][i]/16;
                }
            }
        }
        return mixedBuffers;
    }

    /**
     * Stops streaming the sound to the sound card.
     */
    public void finishWork() {
        keepBuffering = false;
        converter.stopStreaming();
    }

    /**
     * Continuous process of buffering the sound:
     * 1. Add voices that have been recently triggered.
     * 2. Remove the voices that have been finished.
     * 3. Gather the buffers from all the existing voices.
     * 4. Mix all the voice buffers.
     * 5. Post-process the mixed buffers (reverb, delay, volume).
     * 5. Send the processed sound to the output.
     */
    @Override
    public void run() {
        double[][][] allVoiceBuffers;
        keepBuffering = true;
        while (keepBuffering) {
            int bufferSize = converter.getBufferSize();
            acceptNewVoices();
            removeFinishedVoices();
            allVoiceBuffers = gatherAllVoices(bufferSize);
            double[][] mixedVoicesBuffer = mixBuffers(allVoiceBuffers, bufferSize);
            double[][] postProcessedBuffer = createPostProcessedBuffer(mixedVoicesBuffer);
            converter.streamBuffer(postProcessedBuffer);
        }
    }

    /**
     * Get the delay effect used to process the signal of this synthesizer.
     * @return The delay effect used to process the signal of this synthesizer.
     */
    public Delay getDelay() {
        return delay;
    }

    /**
     * Get reverberation effect used to process the signal of this synthesizer.
     * @return The reverberation effect used to process the signal of this synthesizer.
     */
    public Reverb getReverb() {
        return reverb;
    }

    /**
     * Get the envelope settings of the voices generated by this synthesizer.
     * @return The envelope settings of the voices played by this synthesizer.
     */
    public EnvelopeSettings getEnvelopeSettings() {
        return envelopeSettings;
    }

    /**
     * Get the settings of the oscillators that generate sound for this synthesizer.
     * @return The settings of the oscillators that generate sound for this synthesizer.
     */
    public OscillatorSettings getOscillatorSettings() {
        return oscillatorSettings;
    }

    /**
     * Get the converter that is going to stream the signal from this synthesizer to a sound card.
     * @return The converter that is going to stream the signal from this synthesizer to a sound card.
     */
    public Converter getConverter() {
        return converter;
    }

    /**
     * Returns the object responsible for controlling the volume of this synthesizer.
     * @return The object responsible for controlling the volume of this synthesizer.
     */
    public Volume getVolume() {
        return volume;
    }
}
